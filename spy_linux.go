package procspy

import (
	"bytes"
	"sync"
)

const (
	tcpEstablished = 1 // according to /include/net/tcp_states.h
)

// sync.Pool turns out cheaper than keeping a freelist.
var bufPool = sync.Pool{
	New: func() interface{} {
		return bytes.NewBuffer(make([]byte, 0, 5000))
	},
}

// Connections returns all established (TCP) connections.
// No need to be root to run this.
func Connections() ([]Connection, error) {
	var c []Connection
	buf := bufPool.Get().(*bytes.Buffer)
	for _, procFile := range []string{
		procRoot + "/net/tcp",
		procRoot + "/net/tcp6",
	} {
		buf.Reset()
		if err := readFile(procFile, buf); err != nil {
			// File might not be there if IPv{4,6} is not supported.
			continue
		}
		// Only read established connections.
		c = append(c, parseTransport(buf.String(), tcpEstablished)...)
	}
	bufPool.Put(buf)
	return c, nil
}

// Processes gets the list generated by Connections, and tries to find the
// process which handles the connection.
// Only connections for which we found a process are returned.
// You need to be root to find all processes.
func Processes(c []Connection) ([]ConnectionProc, error) {
	return procProcesses(c), nil
}
